// Copyright Â©2019 The rgonomic Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package codegen

import (
	"fmt"
	"go/types"
	"path"
	"strings"
	"text/template"
	"unicode"
)

// TODO(kortchak): Check input types for validity before making .Call.

// rCall is the template for R .Call function file generation.
func RCallTemplate(words []string) *template.Template {
	return template.Must(template.New("R .Call").Funcs(template.FuncMap{
		"base":    path.Base,
		"snake":   snake(words),
		"varsOf":  varsOf,
		"names":   names,
		"doc":     doc,
		"returns": returns,
		"seelso":  seelso,
		"replace": strings.ReplaceAll,
	}).Parse(`{{$pkg := .Pkg}}# Code generated by rgnonomic/rgo; DO NOT EDIT.

#' @useDynLib {{base $pkg.Path}}{{range $func := .Funcs}}
{{$params := varsOf $func.Signature.Params}}
#' {{$func.Func.Name}}
#'
#' {{replace $func.FuncDecl.Doc.Text "\n" "\n#' "}}
{{range $p := $params}}{{doc $p}}
{{end}}{{returns $func.Signature.Results}}{{seelso $pkg $func.Func}}
#' @export
{{snake $func.Func.Name}} <- function({{names false $params}}) {
	.Call("{{snake $func.Func.Name}}"{{names true $params}}, PACKAGE = "{{base $pkg.Path}}")
}{{end}}
`))
}

// doc returns an R documentation line for the variable v.
func doc(v *types.Var) string {
	return fmt.Sprintf("#' @param %s is %s", v.Name(), rTypeFor(v.Type()))
}

// seealso returns an @seealso documentation line linking to the fn's
// godoc.org documentation.
func seelso(pkg *types.Package, fn *types.Func) string {
	return fmt.Sprintf("#' @seelso <https://godoc.org/%s#%s>", pkg.Path(), fn.Name())
}

// returns returns an R documentation table for the returned values in t.
func returns(t *types.Tuple) string {
	if t.Len() == 0 {
		return ""
	}
	var buf strings.Builder
	switch t.Len() {
	case 0:
	case 1:
		v := t.At(0)
		typ := rTypeFor(v.Type())
		name := v.Name()
		if name != "" {
			name = ", " + name
		}
		fmt.Fprintf(&buf, "#' @return %s value%s\n", article(typ, true), name)
	default:
		fmt.Fprintf(&buf, "#' @return A structured value containing:\n")
		for i := 0; i < t.Len(); i++ {
			v := t.At(i)
			typ := rTypeFor(v.Type())
			name := v.Name()
			if name == "" {
				name = fmt.Sprintf("r%d", i)
			}
			fmt.Fprintf(&buf, "#' @return - %s, $%s\n", article(typ, false), name)
		}
	}
	return buf.String()
}

var typeNameTable = map[string]string{
	"float64":   "double",
	"[]float64": "double vector",
	"int":       "integer",
	"[]int":     "integer vector",
	"string":    "character",
	"[]string":  "character vector",
	"bool":      "logical",
	"[]bool":    "logical vector",
	"error":     "character vector",
	"[]byte":    "raw",
}

// rTypeFor returns a string describing the R type based on the given Go type.
func rTypeFor(t types.Type) string {
	s := t.String()
	r, ok := typeNameTable[s]
	if !ok {
		u := t.Underlying()
		if t == u {
			return "an R type corresponding to " + article(s, false)
		}
		return rTypeFor(u)
	}
	return r
}

// article returns a correct article for a given noun.
func article(noun string, capital bool) string {
	vowel := "a"
	if capital {
		vowel = "A"
	}
	switch unicode.ToLower(rune(noun[0])) {
	case 'a', 'e', 'i', 'o', 'u':
		return vowel + "n " + noun
	default:
		return vowel + " " + noun
	}
}
